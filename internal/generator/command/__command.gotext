package command

{{- if $.Imports }}

import (
	{{- range $import := $.Imports }}
	{{$import.Name}} "{{$import.Path}}"
	{{- end }}
)
{{- end }}

func Parse(args ...string) int {
	cli, err := Load()
	if err != nil {
		console.Error(err.Error())
		return 1
	}
	if err := cli.Parse(args...); err != nil {
		if errors.Is(err, context.Canceled) {
			// Unfortunately interrupts like SIGINT trigger a non-zero exit code,
			// regardless of whether you do os.Exit(0) or not. We're going to use exit
			// code 3 to distinguish between non-zero exit codes so "bud run" can know
			// that we exited cleanly on an interrupt.
			return 3
		}
		console.Error(err.Error())
		return 1
	}
	return 0
}

func Load() (*CLI, error) {
	wd, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	modFile, err := mod.Default().Find(wd)
	if err != nil {
		return nil, err
	}
	genFS := gen.New(os.DirFS(modFile.Directory()))
	genFS.Add(map[string]gen.Generator{
		"bud/plugin": gen.DirGenerator(&plugin.Generator{Modfile: modFile}),
	})
	cmd, err := load()
	if err != nil {
		return nil, err
	}
	return &CLI{cmd}, nil
}

type CLI struct {
	cmd *Command
}

func (c *CLI) Parse(args ...string) error {
	// $ bud run
	// $ bud build
	cmd := commander.New("app")
	cmd.Run(c.cmd.Run)

	{ // $ bud deploy
		cmd := cmd.Command("deploy", "deploy to production")
		cmd.Flag("access-key", "aws access key").String(&c.cmd.deployCommand.AccessKey)
		cmd.Flag("secret-key", "aws secret key").String(&c.cmd.deployCommand.SecretKey)
		cmd.Run(c.cmd.deployCommand.Run)
	}

	{ // $ bud new
		cmd := cmd.Command("new", "new scaffolding")

		{ // $ bud new view
			cmd := cmd.Command("view", "create a new view")
			cmd.Arg("name", "name of the view").String(&c.cmd.newViewCommand.Name)
			cmd.Flag("with-test", "add a test").Bool(&c.cmd.newViewCommand.WithTest).Default(true)
			cmd.Run(c.cmd.newViewCommand.Run)
		}
	}

	return cmd.Parse(args)
}


// TODO: generate with di using the newCmd
func load() (*Command, error) {
	awsConfig := aws.New()
	webServer := &web.Server{Config: awsConfig}
	commandcommand, err := NewCommand(webServer)
	if err != nil {
		return nil, err
	}
	command1deployCommand, err := NewDeployCommand(awsConfig)
	if err != nil {
		return nil, err
	}
	command2newViewCommand, err := NewNewViewCommand()
	if err != nil {
		return nil, err
	}
	command3webServeCommand, err := NewWebServeCommand(webServer)
	if err != nil {
		return nil, err
	}
	command4Command := New(commandcommand, command1deployCommand, command2newViewCommand, command3webServeCommand)
	return command4Command, err
}

func New(
	command *command,
	deployCommand *deployCommand,
	newViewCommand *newViewCommand,
	webServeCommand *webServeCommand,
) *Command {
	return &Command{
		command:         command,
		deployCommand:   deployCommand,
		newViewCommand:  newViewCommand,
		webServeCommand: webServeCommand,
	}
}

type Command struct {
	command         *command
	deployCommand   *deployCommand
	newViewCommand  *newViewCommand
	webServeCommand *webServeCommand
}

func NewCommand(web *web.Server) (*command, error) {
	return &command{
		Web: web,
	}, nil
}

// Root app command
type command struct {
	Web *web.Server
}

func (c *command) Run(ctx context.Context) error {
	fmt.Println("run or build command")
	return nil
}

// Deploy command
type deployCommand = deploy.Command

func NewDeployCommand(awsConfig *aws.Config) (*deployCommand, error) {
	return &deployCommand{
		Config: awsConfig,
	}, nil
}

type newViewCommand = new_view.Command

func NewNewViewCommand() (*newViewCommand, error) {
	return &newViewCommand{}, nil
}

type webServeCommand = web_serve.Command

func NewWebServeCommand(web *web.Server) (*webServeCommand, error) {
	return &webServeCommand{
		Web: web,
	}, nil
}

