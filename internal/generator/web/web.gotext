package web

// GENERATED. DO NOT EDIT.

{{- if $.Imports }}

import (
	{{- range $import := $.Imports }}
	{{$import.Name}} "{{$import.Path}}"
	{{- end }}
)
{{- end }}

// New web server
func New(
	router *router.Router,
	hot *hot.Server,
	public public.Middleware,
	view *view.Server,
) *Server {
	// Compose the middleware together
	middleware := middleware.Compose(
		public,
		hot,
		view,
		router,
	)
	handler := middleware.Middleware(http.NotFoundHandler())
	return &Server{handler}
}

type Server struct {
	http.Handler
}

func (s *Server) ListenAndServe(ctx context.Context, address string) error {
	server := &http.Server{
		Addr: address,
		Handler: s,
	}
	// Make the server shutdownable
	shutdown := shutdown(ctx, server)
	// Serve requests
	if err := server.ListenAndServe(); err != nil {
		if !errors.Is(err, http.ErrServerClosed) {
			return err
		}
	}
	// Handle any errors that occurred while shutting down
	if err := <-shutdown; err != nil {
		return err
	}
	return nil
}

// shutdown the server when the context is cancelled
func shutdown(ctx context.Context, server *http.Server) <-chan error {
	shutdown := make(chan error, 1)
	go func() {
		<-ctx.Done()
		// Wait for one more interrupt to force an immediate shutdown
		forceCtx, cancel := commander.Trap(context.Background(), os.Interrupt)
		defer cancel()
		if err := server.Shutdown(forceCtx); err != nil {
			shutdown <- err
		}
		close(shutdown)
	}()
	return shutdown
}
